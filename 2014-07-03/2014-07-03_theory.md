# Theory part 03/07/2014

## Point 1

### Question

(3.0 marks) What is a relative pathname? What is an absolute pathname? Why is it important for the kernel to know the current directory of the running process? What is the content of an inode? Why not keeping the inode information in the directory?

### Solution

Relative pathnames specify the location of files and directories in relative terms. The destination is reached by starting from the current working directory and following names of path tokens.

Absolute pathnames specify the location of files and directories in absolute terms. The destination is reached by starting from the (changed) root node and following names of path tokens. Absolute pathnames always begin with the `/` character, that identifies the root node.

The kernel needs to know the current directory of the running process in order to satisfy system calls that internally use the `namei` algorithm, because the path provided can be both absolute and relative.

The content of an inode (on disk) is:

* owner and owner group
* permissions (read, write, execute) for owner, group and others
* type of inode (directory, normal file, FIFO, ...)
* link count
* the file size
* time informations:
  * last file access
  * last file modification
  * last inode modification
* pointer to content blocks:
  * 10 direct blocks
  * 1 indirect, 1 double indirect and 1 triple indirect pointer to data blocks

The inode content is not stored into the directory because multiple links are possible to the same file, and consistency should be kept within multiple entries. Instead in the directory is stored only the name of the link and the inode number, that allows to reach the inode that is unique for each file.

## Point 2

### Question

(3.0 marks) Which is the Unix command for copying an entire disk to another file? Give one or more examples. Explain which is the syntax, the options, and the function offered by the system call `losetup`. Give examples. Which is the difference between a raw and a block device?

### Solution

The command is `dd` that does a copy from a file (specified with `if=/path/to/src`) to another file (specified as `of=/path/to/dst`). The files can be regular files or can be any device file. It can be used to copy disks, partitions and anything that is identified by a file in the filesystem.

For example the following copies the disk `sdb` to the file `img.hd`:

`dd if=/dev/sdb of=img.hd`

Or this other example writes the image file `part.hd` to the third partition of `sdb`:

`dd if=part.hd of=/dev/sdb2`

Additional parameters can be used to specify the block size (`-bs=nbytes`) and the maximum number of blocks to copy (`count=nblocks`).

The system call `losetup` associates a loopback device with a regular file. For example the command `losetup /dev/loop1 hd.img` makes the file `hd.img` to be available as a block device by using the special file `/dev/loop1`. The loopback device can be used with tools that manage a partition table, and if it contains a filesystem it can be mounted and accessed. There are some options to this command:

* `-o offset` to specify the offset from the beginning of the file on which start the association
* `--sizelimit limit` to specify a limit on the binding, in this way the maximum size of the device is specified
* `-d loopdevice` to detach the loopdevice, undoing the loop setup

The differences between raw and block devices are caused by the fact that block devices make use of buffer caches.

* a block device can be read/written by using system calls specifying arbitrary offset and length. The operating system will manage the buffering and will perform the reads and writes on blocks opportunely
* raw devices operation are direct, so if the underlying harware is for example an hard drive, IO operations must be done aligned

Relative performances can vary. Block devices provide buffering, that is useful if the same data is accessed more times. Instead for sequential read of large amount of data, raw devices provide a better performance since there is no double-copy (from device to buffer and from buffer to destination). A single device can provide two different interfaces: a raw one and a block one.

## Point 3

### Question

(3.0 marks) Given this reference string: `1233343251154323345241345`, compute the number of page faults and the mean resident set for the Page Fault Frequency strategy with control parameter `C=2`.

### Solution

time             |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  | 21  | 22  | 23  | 24  | 25  |
---------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
reference string |  1  |  2  |  3  |  3  |  3  |  4  |  3  |  2  |  5  |  1  |  1  |  5  |  4  |  3  |  2  |  3  |  3  |  4  |  5  |  2  |  4  |  1  |  3  |  4  |  5  |
|
                 |**1**|**1**|**1**|**1**|**1**|  1  |  1  |  1  |  5  |  5  |  5  |**5**|  5  |  5  |  5  |  5  |  5  |  5  |**5**|**5**|**5**|**5**|**5**|**5**|**5**|
                 |     |**2**|**2**|**2**|**2**|  2  |  2  |**2**|  2  |  2  |  2  |  2  |  4  |  4  |  4  |  4  |  4  |**4**|**4**|**4**|**4**|**4**|**4**|**4**|**4**|
                 |     |     |**3**|**3**|**3**|  3  |**3**|**3**|  3  |  3  |  3  |  3  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |  1  |**1**|**1**|**1**|**1**|
                 |     |     |     |     |     |  4  |  4  |  4  |     |**1**|**1**|**1**|     |**3**|**3**|**3**|**3**|**3**|**3**|**3**|**3**|**3**|**3**|**3**|**3**|
                 |     |     |     |     |     |     |     |     |     |     |     |     |     |     |**2**|**2**|**2**|**2**|**2**|**2**|**2**|**2**|**2**|**2**|**2**|
|
fault            |  x  |  x  |  x  |     |     |  x  |     |     |  x  |  x  |     |     |  x  |  x  |  x  |     |     |     |     |     |     |     |     |     |     |
ref              |     |     |     |     |     |  0  |     |     |  0  |     |     |     |  0  |     |     |     |     |     |     |     |     |     |     |     |     |

Number of faults: `9`

Mean resident set: `101/25`

## Point 4

### Question

(3.0 marks) Which are the roles of file pointers and of the overlapped structures in direct file access on WIN32 systems. Briefly describe common aspects and differences. The prototype of function `ReadFile` is:

```c
BOOL ReadFile (HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
```

how can we handle pointers to large files? What is a `LARGE_INTEGER` type in Win32? How can we increment a `LARGE_INTEGER` variable by 1? Given a file of size 6 GB, containing records of fixed size 128 Bytes, how can we read record n. `2^15` (records are numbered starting from 0)?  
Provide the solution with file pointers and with overlapped structure.

### Solution

TODO

## Point 5

### Question

(3.0 marks) Explain the main differences between user and kernel mode drivers in WindowsCE and Windows Embedded 7. Given figure represented below, briefly describe the role of the user mode driver, of device manager and of the reflector service. What is `udevice.exe`? Is the user mode driver linked within the kernel (dynamically or statically)? When you write a used application, do you need to differentiate IO calls serviced by user mode drivers from those served by kernel mode drivers?

![2014-07-03_theory_usermodearchitecture.png](2014-07-03_theory_usermodearchitecture.png "User mode driver architecture")

### Solution

TODO
