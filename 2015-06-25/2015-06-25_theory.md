# Theory part 25/06/2015

## Point 1

### Question

Write the sequence of instructions that allow the bash process to interpret and execute the command

    `p1 | p2 > f1.txt`

where p1 and p2 are two executable files.

### Solution

```c
int fds[2];
pipe(fds);
if(!fork()) {
    // child (p1)
    close(fds[0]); // close read end of pipe
    close(1);
    dup(fds[1]); // p1 writes to pipe
    close(fds[1]); // write pipe duplicated
    execlp("p1", "p1", NULL);
    exit(255); // reached only on exec fail
}
close(fds[1]);
if(!fork()) {
    // child (p2)
    close(0);
    dup(fds[0]); // p2 reads from pipe
    close(fds[0]);
    close(1);
    open("f1.txt", O_WRONLY | O_CREAT | O_TRUNC, 0640); // p2 writes to file
    execlp("p2", "p2", NULL);
    exit(255); // reached only on exec fail
}
close(fds[0]);
wait(NULL);
wait(NULL);
```

## Point 3

### Question

Explain the behaviour of `WaitForSingleObject` and `WaitForMultipleObjects` in WIN32.  
Are calls to the two functions blocking? What can we wait for, with the two functions? How many, and which, different synchronization schemes are possible through WFMO? Is it possible to use WFMO in order to wait for one among multiple events/objects?  
What does constant `WAIT_OBJECT_0` represent?

Given the following loop, where the tHandles array is an array of handles of running threads, and processThreadResult works on the result produced by a thread, explain what the loop does.

```c
/* wait thread completion 1 */
for (iThrd = 0; iThrd < N; iThrd++) {
    WaitForSingleObject (tHandles[iThrd], INFINITE);
    processThreadResult (tData[iThrd]);
}
```

Since the loop forces a given order in waiting for thread completion, write an alternative loop, based on `WaitForMultipleObjects`, where thread results are processed following an order given by thread completions.

### Solution

`WaitForSingleObject` and `WaitForMultipleObjects` can be used to wait for handles to be in a signalled state. The handle can for example represent a file, an event, a mutex, a semaphore, a thread.  
Both function have a parameter that can be used to choose a timeout for the operation. Depending on this parameter the call can be blocking (timeout = INFINITE) or not (timeout = 0) or a timed wait (with a finite timeout).  
`WaitForSingleObject` waits for a single handle, while `WaitForMultipleObjects` waits for more (up to WAIT_MAXIMUM_OBJECTS) handles passed as an array. The last function has a boolean parameter (`bWaitAll`) that specifies the synchronization scheme:

* `bWaitAll = TRUE` means that the function will return only after all the handles are in signalled states (or timeout expired)
* `bWaitAll = FALSE` means that the function will return after at least one handle is signalled. To identify it in the array, the return value of the function must be subtracted with the constant `WAIT_OBJECT_0` and this will produce the index to be used to access the array.

The loop in the example is iterating over the array of handles: waits for the thread to be ended and then processes its result. The loops forces an order of execution, and we may loose time waiting for a thread while results of other threads could be processed. To avoid this, another synchronization scheme must be used.

```c
INT i, n, iThrd;
LPINT indexes = calloc(N, sizeof(INT));
// initialize the indexes
for (i = 0; i < N; i++) {
    indexes[i] = i;
}
n = N;
while (n > 0) {
    i = WaitForMultipleObjects(n, tHandles, INFINITE) - WAIT_OBJECT_0; // i is the index in the shrinked array
    iThrd = indexes[i]; // this is the real index of the thread
    indexes[i] = indexes[--n]; // shrink the indexes
    tHandles[i] = tHandles[n]; // shrink the handles (the last one is put in the current positon)
    processThreadResult(tData[iThrd]); // the tData array elements cannot be moved because accessed by the thread
}
```

## Point 4

### Question

Explain the main features of dynamic libraries in Win32. Motivate the main advantages of dynamic libraries vs. static ones. Explain the difference between implicit and explicit linking. What kind of modification is required by a program in order to become a dynamic library (answer for both implicit and explicit linking).

### Solution

TODO

## Point 5

### Question

Which are the roles of files pointers and of the overlapped structures in direct file access on WIN32 systems. Briefly describe common aspects and differences. Provide a brief example of application for both of them. How can we increment by 100 bytes a file pointer in an overlapped structure? (provide an example)  
Does an overlapped structure include an event? Is it automatically created? When is it signaled?

### Solution

TODO