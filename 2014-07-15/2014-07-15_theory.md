# Theory part 15/07/2014

## Point 1

### Question

(3.0 marks)  
a) Describe events in the Windows system and their related system calls. Describe the 4 cases of event signal/release, related to manual/auto reset and set/pulse event conditions.  
b) Given a set of threads working in master-slave mode, with one master and N slaves, we want to use events for two purposes:

* for the master, in order to wait for task completion from a slave (any slave can complete a task under execution at a given time): events are used to communicate completion from a slave to the master
* for the master, to enable a specific slave to start a new task

How many events are necessary? `1`, `2`, `N`, `N+l`, `2N`, `2N+1`, `2N+2`? (motivate your answer)  
Which kind of events (manual/auto, set/pulse)? Why? (handling of tasks and data is NOT required, just propose a solution for synchronization)

### Solution

a) Events are system kernel objects that can be managed with the following system calls:

* `CreateEvent` creates a new event. Its parameters are:
  * security attributes (optional)
  * a name: can be used to allow a `OpenEvent` system call to open the existing named event. This parameter is optional
  * auto reset / manual reset flag: specifies the type of event created
  * initial state: to set the initial state to signalled or not
* `OpenEvent` to open an existing named event
* `SetEvent` sets the state of the event to signalled
* `ResetEvent` sets the state of the event to not-signalled
* `PulseEvent` sets the event to signalled and resets it before new threads interrogate its status
* `WaitForSingleObject` and `WaitForMultipleObjects` can be used to wait until the event is signalled
* `CloseHandle` to decrement the reference count to the event and delete it when appropriate

Four possible cases are possible:

|             | auto-reset | manual-reset
------------- | --- | ---
| `SetEvent`  | exactly one thread is released. If there are currently no threads waiting, the first one to arrive will be released | all the threads waiting are released. All new threads arriving will not be blocked until someone calls `ResetEvent`
| `PulseEvent`| exactly one waiting thread is released. If there are no threads waiting, no thread will be released when arriving to wait | all the threads waiting are released. New threads arriving will be blocked

b) `2N` auto-reset events are necessary. `N` are needed for the master to enable a specific slave, and other `N` are needed to signal to the master that a specific slave has completed his work. These two sets cant be the same because if the master sets an event to enable a thread and then goes to wait on this event, there is no warranty that the event will unlock the slave and not the master (waiting on the same event). The events need to be auto-reset in the case that the slave processes are cyclic (the master enables a slave to start a single task, not to continue looping on new works). The threads will use the `SetEvent` instead of `PulseEvent` in order to avoid lost signals.

```c
LPHANDLE masterEvt, slaveEvt;

INT _tmain(INT argc, LPTCSTR argv[]) {
    // ...
    masterEvt = calloc(nSlaves, sizeof(HANDLE));
    slaveEvt = calloc(nSlaves, sizeof(HANDLE));
    for(i = 0; i < nSlaves; i++) {
        real_ids[i] = i;
        masterEvt = CreateEvent(NULL, FALSE, FALSE);
        slaveEvt = CreateEvent(NULL, FALSE, FALSE);
        CreateThread(NULL, 0, slave, i); // i passed by value
    }
    //...
    for(i = 0; i < nSlaves; i++) {
        EnableSlave(i); // enable a specific slave
    }
    while(TRUE) {
        // wait for any slave to complete a work
        id = WaitForMultipleObjects(nSlaves, masterEvt, INFINITE, FALSE) - WAIT_OBJECT_0;
        ProcessResult(id);
        EnableSlave(id); // re-enable this slave (to do a new job)
    }
}

// this function is called by the master to enable a slave
VOID EnableSlave(INT id) {
    SetEvent(slaveEvt[id]);
}

DWORD WINAPI slave(LPVOID arg) {
    INT id = (INT) arg;
    // ...
    while(TRUE) {
        WaitForSingleObject(slaveEvt[id]);
        Work();
        SetEvent(masterEvt[id]);
    }
}
```

## Point 2

### Question

(3.0 marks) Describe the main differences between static and dynamic libraries, and answer the following questions:

* What are implicit and explicit linking, within the framework of dynamic libraries?
* When are (explicitly/implicitly linked) libraries linked: at compile- load- or execution-time?
* Are DLLs required to be thread-safe (motivate the yes/no answer, and also explain what is threadsafety)?
* Can a DLL be shared, at runtime, among processes?
  * If (the answer is) yes, can it be used to share data among processes using them (e.g. to hold a shared array for reading/writing)?
  * If (the answer is) no, how can a library routine be shared (a single copy is resident in memory) among several processes?

### Solution

Static libraries are compiled from source code together to produce a single executable file that will contain all the instructions needed. Dynamic libraries instead follow a separated compilation process and are loaded for the executable file at load time or at runtime. If a static library is modified, the executable must be recompiled. Instead if the library is dynamic and the changes are internal (not affecting the interface) only the library must be recompiled alone. With dynamic libraries it's also possible to exchange different versions of the library by simply replacing the dll file in the execution directory.

* Implicit linking is done at **load time** automatically. The steps needed are:
  * Export the functions in the dll by using the `__declspec(dllexport)` as a storage modifier
  * in the calling program declare the prototypes of the functions belonging to the dll with the `__declspec(dllimport)` storage modifier (the two steps can be made one by playing in the header file with `#define`s). In this way the functions can be called like any other extern function.
  * compile the library: the procedure will create a `.dll` file and a `.lib` one (that contains stubs for loading and calling the library)
  * compile the calling program linking together the `.lib` file
  * run the calling program including the `.dll` file in the execution directory
* Explicit linking is done at **execution time**. The steps needed are:
  * Produce the dll file like with implicit linking
  * in the calling program do the following:
    * declare a function pointer having the same signature as the function to be loaded from the dll
    * call `LoadLibrary` by passing the name of the `.dll` file
    * call `GetProcAddr` by passing the result of the previous step and the name of the function exported by the dll
    * cast the result (from `FARPROC`) to the correct signature and assign it to the function pointer
    * call the function
* DLLs must be designed thread-safe because we can't trust the caller. In a multithreaded environment the calls could be done without care, so the library should internally be thread safe. Thread-safety means that, if different threads operate concurrently on the functions, the result must be corrent and coherent to any serialized set of calls. This can be achieved by using some mutual exclusion mechanism to protect shared data.
* DLLs can be loaded simultaneously by different processes, although every process will get a private copy of the global variables declared in the DLL in its addressing space. In this way it is not possible to share data between different processes using the same DLL.

## Point 3

### Question

(3.0 marks) Explain the behaviour of WaitForSingleObject and WaitForMultipleObjects in WIN32. 

Are calls to the two functions blocking? What can we wait for, with the two functions? How many, and which, different synchronization schemes are possible through WFMO? Is it possible to use WFMO in order to wait for one among multiple events/objects?

Given the two wait loops written below, explain their wait scheme. Are the calls to WFMO in loop1/loop2 waiting for completion of all, or for one, among many processes/threads? If yes, is the waiting order fixed?

Is it possible to detect which of the waited processes/threads has completed? What does constant `WAIT_OBJECT_0`) represent? Why the first parameter in loop1 is `min (MAXIMUM_WAIT_OBJECTS, argc - 2 - iProc)`, instead of `nProc` ? What are `hProc` and `tHandle`?

```c
/* loop 1 */
for (iProc = 0; iProc < nProc; iProc += MAXIMUM_WAIT_OBJECTS)
    WaitForMultipleObjects (min (MAXIMUM_WAIT_OBJECTS, argc - 2 - iProc), &hProc[iProc], TRUE, INFINITE);
/* loop 2 */
while (ThdCnt >0) {
    ThdIdxP = WaitForMultipleObjects (ThdCnt, tHandle, FALSE,INFINITE);
    iThrd = (int) ThdIdxP - (int) WAIT_OBJECT_0;
    if (iThrd < 0 || iThrd >= ThdCnt)
        ReportError (_T ("Thread wait error."), 5, TRUE);
    GetExitCodeThread (tHandle [iThrd], &ExitCode);
    CloseHandle (tHandle [iThrd]);
}
```

### Solution

TODO

## Point 4

### Question

(3.0 marks) Detail the steps performed by the system call close, with reference to all the objects and data structures involved by its operations.

### Solution

TODO

## Point 5

### Question

(3.0 marks) Explain all the arguments of this command line:

`qemu -hdb fs.img xv6.img -serial mon:stdio -S -gdb tcp::26000 -smp 2 -m 512`

### Solution

TODO
